интерпритация байтов зависит от кодировки, и кодировки должны совпадать
с регулярными выражениями может совпадать не текст, а позиция
!!! пробел это символ !!!
Позиционная проверка не поглощает текст, т.е. выбирает не текст, а позицию


\   экранирование

Метасимволы
^   начало строки
$   конец строки
.   один любой символ
[]  символьный класс. любой из перечисленных внутри кв.скобок символ
()  группировка
|   выбор

\t  табуляция
\n  новая строка
\r  возврат курсора
\s  любой "пропускной" символ
\S  всё, что не \s
\w  [a-zA-Z0-9_]
\W  всё, что не \w
\d  цифра. [0-9]
\D  не цифра. [^0-9]

Метапоследовательности
\1  обратная ссылка номер 1
    ссылки нумеруются по порядку слева направо
\<  начало слова
\>  конец слова

(?:     несохраняющие круглые скобки

(?=     позитивная опережающая позиционная проверка
(?!     негативная опережающая позиционная проверка
(?<!    негативная ретроспективная позиционная проверка
(?<=    позитивная ретроспективная позиционная проверка


Квантификаторы
?   0 или один предшествующий символ
+   один или больше предшествующий символ
*   0 или больше предшествующий символ
{min,max}   интервальный квантификатор. может не поддерживаться

внутри []
^   инвертированный символьный класс. префикс.  [^a]    любое, что не а.    
-   интервал    [0-9]   от 0 до 9
    если стоит не между, то литерал

Диалект регулярного выражения - состав и интерпритация поддерживаемых метасимволов.
Синтаксис взаимодействия регулярных выражений с языком или программой.
Специфика текста.

1940-e - начало
Математик Стивен Клин. Дал формальное описание регулярным множествам. 
Математическая запись стала называться регулярными выражениями.
1950-60-е - развитие
многие метасимволы не поддерживались

grep Global Regular Expressions Print

egrep - extension grep
    применение квантификаторов к круглым скобкам
смутное время регулярки.

posix Portable Operating System Interface -1986
диалекты делятся на 
    BRE Basic Regular Expressions
    ERE Extended Regular Expressions
!! Локальный контекст. Locale - совокупность параметров, описывающая языковые и национальные
    правила - формат даты, времени, денежной величины, интерпретация символов активной кодировки
    и т.д.
    В \w включаются все буквы и цифры, определенные в локальном контексте, а не только из ASCII.

1986 - Пакет Генри Спенсера. первый пакет, написанный на С.
1987 - первая версия Perl
1994 - историческая 5 версия Perl. несохраняющие круглые скобки, опережающая проверка, ...

Веб.
Perl-совместимые пакеты для Tcl, Python, .NET, Ruby, PHP, C/C++, Java

1997 - PCRE Perl Compatible Regular Expressions - библиотека

------------

различия в семантике поиска. 

синтаксическая обёртка - то, как интерпритатор понимает, что это регулярное выражение

3 подхода к обработке регулярных выражений 
    интегрированный
        встраивается в язык
    процедурный
        не встраивается
        функции
    объектно-ориентированный
        не встраивается
        конструкторы и методы

Объектно-ориентированный подход
Java
java.util.regex.*; 
от Sun
 Например.
 Анализируется регулярное выражение и компилируется во внутреннюю форму. Результат - объект Pattern.
 Объект регулярного выражения ассоциируется с текстом. Результат - объект Matcher.
 регулярное выражение применяется к тексту. Метод find проверяет соответствие и возвращает результат.
 При наличии совпадений текст присваивается переменной.

 процедурный подход
 java
 то же
 if(! Pattern.matches("\\s*", line)){...}

 регулярное выражение неявно заключается между символами ^ $ и возвращает логическую величину - 
 признак возможного совпадения во входной строке.
 пакет от сан интегрирован со строковым классом и можно делать, например,
 if (! line.matches("\\s*", ))
 но это ресурсоёмко.

 оператор поиска и замены в перле работает непосредственно со строкой и по окончании операции 
 строка оказывается модифицированной.
 в большинстве языков создается копия строки и уже копия модифицируется.
 после можно перезаписать оригинальную строку.

 в java обратные слеши должны экранироваться, например, \w пишется как \\w
 вместо модификаторов используются функции или флаги, передаваемые при вызове.

 в php похоже на перл

 в Emacs встроен elisp

 Строки как регулярные выражения
 кроме перла, awk и sed, 
 регулярные выражения передаются как строки, определенные в виде литералов вида "From: (.*)"
 строковые литералы обладают собственным набором метасимволов.
 обычно распознаются последовательности вроде \t, \n.
 часто надо экранировать слеши
 !!! 
 если регулярное выражение задается в режиме свободного форматирования /x, то 
 new line превращается в ничто, а \n остаётся рег.выр., совпадающим с символом новой строки.

 2A - ASCII символ *

 !!!!
 что именно получит механизм регулярных выражений после того, как строка будет обработана по правилам языка?
 !!!!

 Строковые литералы Java
 Заключаются в кавычки
 \ метасимвол
 \t \n \\ и многие другие стандартные комбинации поддерживаются
 использование \ в неподдерживаемой комбинации приводит к ошибке.

 в Перл выражения могут задаваться как строки, но литералы эффективнее - интерполяция, задача символов юникода по именам,
  поддержка литерального режима с использованием синтаксиса \Q...\E

  ////////////// 145 проблемы кодировки символов.

  /*
  JavaScript
  нужно экранировать круглые скобки
  выражения заключаются в обратные слеши
  есть /g
  */

  понимает ли программа кодировку?
  откуда она узнает о правилах интерпритации символов?
  каким уровнем возможностей работы с регулярными выражениями обладает кодировка?
        распознаются ли символы, закодированные несколькими байтами?
            символы внутри символьного класса распознаются как символ или байт?
        распознают ли \w и др. весь набор кодировки
        расширяет ли программа [a-z]
        работает ли \i 

///
юникод.
- набор символов, или концептуальная кодировка. Логическое отображение между числами и символами.
число - кодовый пункт.

по идее, разница между utf-8 и utf-16, не должна волновать, но иногда появляются нюансы.

сложности со штуками типа а с акцентом
буква + диакритический знак.
на практике метасимвол . совпадёт с каждым пунктом в отдельности. а с акцентом - ^..$ а не ^.$
в перле есть метапоследовательность \X , . совпадает с !базовым! символом а, за которым следует 
какое-то количество комбинационных (асенту гравэ, сыркумфлексу и т.д.).

если за комбинационным символом следует квантификатор, то квантификатор применяется только к последнему.

два варианта кодирования для совместимости юникода с latin-1 (ISO-8859-1)

поиск диких символов \x{1D12}

///////////////
Режимы поиска и обработки регулярных выражений

    Поиск без учета регистра символов

Не во всех языках есть регистр, может быть отдельный титульный регистр, может быть вообще всё сложно:
греческая сигма имеет два представления в нижнем регистре. (реализовано в перле и java.util.regex).

    Свободное форматирование и комментарии

    Совпадение точки со всеми символами
    (однострочный режим)

Обычно точка не совпадает с началом строки. и с концом.
но чаще всего есть режимы для совпадения и несовпадения.
/s 
single-line
с однострочностью связан только буквой.

    Расширеный режим привязки к границам строк

якорные метасимволы ^ $ разбивают текст на логические строки.
в программах часто существуют символы \A \Z 
многострочный режим на них не распространяется.
Системы с поддержкой юникода могут допускать совпадение якорных метасимволов с любым завершающим символом. см. скриншот.

    Литеральный режим.

не распознаётся большинство метасимволов. 
напр. в перл есть \Q \E между которыми всё становится литералами.
                    